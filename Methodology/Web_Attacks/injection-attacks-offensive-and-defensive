# Web Attack 02 – Injection Attacks (SQL Injection & Command Injection)

In this section, I tested SQL Injection and Command Injection vulnerabilities in DVWA by first analyzing each page’s functionality to understand what backend components were involved. Based on this understanding, I selected appropriate payloads, automated testing using Burp Intruder, and then validated detection using Apache access logs in Splunk.

---

## How I Approached Injection Attacks (Offensive)

Before sending any payloads, I reviewed what each DVWA page was designed to do and what type of backend processing was likely happening.

My goal was not to blindly send payloads, but to **infer how user input was being used** and then test accordingly.

---

## SQL Injection – Page Analysis and Offensive Testing

The DVWA SQL Injection page retrieves user records based on the input provided. Since the page is fetching user information, it strongly indicates that:

- A **database query** is being executed in the backend
- User input is likely included directly in a SQL statement

Based on this functionality, I expected **SQL Injection** to be possible on this page.

I intercepted the request and used Burp Intruder to automatically test SQL-related payloads against the input parameter. This allowed me to efficiently test multiple payload variations and observe how the application responded.

After running the automated attack, I identified payloads that caused abnormal behavior, confirming SQL injection.

Below is one example showing a successful SQL injection attempt observed after the Intruder attack.

![SQL Injection Success Attempt](../../Images/sql_injection_success.png)

To demonstrate how the payloads were tested, the following image shows the SQL injection attack being performed using Burp Intruder.

![Burp Intercepted SQL Injection Attack](../../Images/sql_injection_attack_intruder.png)

---

## Command Injection – Page Analysis and Offensive Testing

The DVWA Command Injection page takes user input and executes system-level operations on the server. From the page behavior, it was clear that:

- User input is passed to an **operating system command**
- Backend OS interaction is involved rather than database queries

Based on this functionality, I expected **Command Injection** to be possible on this page.

I intercepted the request and used Burp Intruder to test command execution payloads. These payloads were designed to check whether user input was being executed by the operating system.

After the automated testing completed, I observed payloads that resulted in successful command execution, confirming the vulnerability.

Below is one example showing a successful command injection attempt identified after the Intruder attack.

![Command Injection Success Attempt](../../Images/cmd_injection_success.png)

Just like SQL injection, I used intruder to find all possible commands that can be injection.

---

## Logs Generated by Injection Attacks

Both SQL Injection and Command Injection testing generated identifiable patterns in the Apache access logs. These logs recorded repeated requests to vulnerable endpoints, abnormal request volumes, and server-side errors that occurred during injection testing.

![Injection Attacks – Apache Access Logs](../../Images/injection_attacks_entire_logs.png)

---

## SQL Injection Detection (GET) – Why This Query Worked

For DVWA SQL Injection (GET), the injected input is included in the URL query string (for example, `?id=...`). Because Apache access logs record the full request URL, Splunk can directly observe SQL injection patterns.

In the output, I observed:

- High request counts originating from the same `src_ip`
- `sample_uris` containing SQL injection indicators such as encoded quotes (`%27`, `%22`), boolean logic (`or`, `and`), and time-based payloads (`sleep`)
- Multiple response statuses (`200`, `500`), which aligns with injection testing behavior

Based on these observations, the detection logic focused on identifying abnormal request patterns targeting the SQL injection endpoint.

![SQL Injection Detection](../../Images/sql_injection_query.png)

---

## Command Injection Detection – Why This Query Worked

For DVWA Command Injection, the injected payload is sent in the POST request body. Since Apache access logs do not log POST bodies, the actual command payloads (for example `; whoami`, `&& id`, `sleep 5`) are not visible in Splunk.

Because of this limitation, detection relied on **behavioral indicators** rather than payload content.

From the logs, I observed:

- Repeated POST requests to the command execution endpoint (`/dvwa/vulnerabilities/exec/`)
- High request volume within short time windows
- Multiple HTTP 500 errors generated during failed command execution attempts
- A consistent user-agent indicating the same tool or browser was used

These indicators allowed reliable detection of command injection activity.

![Command Injection Detection](../../Images/command_injection_query.png)

---

## Detection Outcome

Using these detections, I was able to clearly identify **192.168.60.50** as the attacker host generating the injection-related requests. This confirmed that the detection logic accurately correlated offensive testing with the correct source and successfully identified malicious behavior.
